<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codes on Luca Brugnolini</title>
    <link>https://lucabrugnolini.github.io/code/</link>
    <description>Recent content in Codes on Luca Brugnolini</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Luca Brugnolini</copyright>
    <lastBuildDate>Thu, 11 Jan 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/code/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Julia Packages</title>
      <link>https://lucabrugnolini.github.io/code/code/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lucabrugnolini.github.io/code/code/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/lucabrugnolini/NFP.jl&#34; target=&#34;_blank&#34;&gt;NFP.jl:&lt;/a&gt;
Forecasting Variables using a combinatoric approach and exploiting parallel computing in Julia. &lt;a href=&#34;https://lucabrugnolini.github.io/code/nfp/&#34;&gt;(more)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/lucabrugnolini/VAR.jl&#34; target=&#34;_blank&#34;&gt;VAR.jl:&lt;/a&gt;
Vector autoregressive model in Julia &lt;a href=&#34;https://lucabrugnolini.github.io/code/var/&#34;&gt;(more)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>NFP.jl</title>
      <link>https://lucabrugnolini.github.io/code/nfp/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lucabrugnolini.github.io/code/nfp/</guid>
      <description>

&lt;h4 id=&#34;forecasting-variables-using-a-combinatoric-approach-and-exploiting-parallel-computing-in-julia-nfp-jl-https-github-com-lucabrugnolini-nfp-jl&#34;&gt;Forecasting Variables using a combinatoric approach and exploiting parallel computing in Julia (&lt;a href=&#34;https://github.com/lucabrugnolini/NFP.jl&#34; target=&#34;_blank&#34;&gt;NFP.jl&lt;/a&gt;)&lt;/h4&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Pkg.clone(&amp;quot;https://github.com/lucabrugnolini/NFP.jl&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Given a (balanced) dataset of &lt;em&gt;K&lt;/em&gt; macroeconomic variables, the objective is to select the best model to predict future values of a target variable. The selection procedure consists in (i) select the best &lt;em&gt;iBest&lt;/em&gt; variables according to several out-of-sample criteria and then use these variables in models that use their combination. More specifically:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;the procedure selects the best &lt;code&gt;iBest&lt;/code&gt; variables using two different criteria (mean absolute error and root mean squared error). This selection step is univariate, i.e. the variables are chosen by running a simple regression of the target variable on each variable of the dataset.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;the &lt;code&gt;iBest&lt;/code&gt; variables are combined into set of &lt;em&gt;2, 3, &amp;hellip;, iBest&lt;/em&gt; variables. For each of these sets, the model is estimated and then avaluated out-of-sample. The best model is the one with the lowest out-of-sample &lt;code&gt;MSE&lt;/code&gt;. We also augment each model with the first principal component of all variable in the dataset. Thus, there are a total of &lt;em&gt;2 (2^iBest)&lt;/em&gt; models.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The complexity is &lt;em&gt;O((T-Ts)*2^iBest)&lt;/em&gt; where &lt;em&gt;T&lt;/em&gt; is the sample size, &lt;em&gt;Ts&lt;/em&gt; is the number of observation in the initial estimation window.&lt;/p&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Forecasting US non-farm-payroll one and two months ahead &lt;code&gt;H = [1,2]&lt;/code&gt; using a dataset containing 116 US variables taken from McCracken and Ng (2015). &lt;code&gt;iBest&lt;/code&gt; is set to 16. The code below is an example of parallelization on &lt;code&gt;N_CORE&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;addprocs(N_CORE)
@everywhere using NFP, DataFrames
@everywhere const sStart_s = &amp;quot;01/01/15&amp;quot;                   ## This is the beginning of the out-of-sample window
@everywhere const iSymbol = :NFP                          ## Target variable
@everywhere const vSymbol = [:Date, :NFP, :NFP_bb_median] ## Variables to be removed from the dataset (non-numerical and dep. var.)
@everywhere const H = [1,2]                               ## Out-of-sample horizon
@everywhere const iBest = 16                              ## iBest
@everywhere const ncomb_load = iBest                      ## TODO: remove this option

@everywhere dfData = readtable(joinpath(Pkg.dir(&amp;quot;NFP&amp;quot;),&amp;quot;test&amp;quot;,&amp;quot;data.csv&amp;quot;), header = true)
@everywhere const iStart = find(dfData[:Date] .== sStart_s)[1]


## computes the two steps variable selection
l_plot,r = sforecast(dfData,vSymbol,iSymbol,H,iStart,iBest,ncomb_load)
## `fforecast` uses results previously stored
l_plot,r = fforecast(dfData,vSymbol,iSymbol,H,iStart,iBest,ncomb_load)


# Plot the forecasts
l_plot

## Remove process added
rmprocs(2:N_CORE)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Since &lt;code&gt;readtable&lt;/code&gt; is deprecated in Julia v0.6, it is advisable to start julia&amp;rsquo;s REPL using the &amp;ndash;depwarn=no flag&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; julia --depwarn=no
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>VAR.jl</title>
      <link>https://lucabrugnolini.github.io/code/var/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lucabrugnolini.github.io/code/var/</guid>
      <description>

&lt;h4 id=&#34;vector-autoregressive-model-in-julia-var-jl-https-github-com-lucabrugnolini-var-jl&#34;&gt;Vector Autoregressive model in Julia (&lt;a href=&#34;https://github.com/lucabrugnolini/VAR.jl&#34; target=&#34;_blank&#34;&gt;VAR.jl&lt;/a&gt;)&lt;/h4&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;Pkg.clone(&amp;quot;https://github.com/lucabrugnolini/VAR.jl&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This package is a work in progress for the estimation and identification of Vector Autoregressive (VAR) model.&lt;/p&gt;

&lt;h2 id=&#34;status&#34;&gt;Status&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; VAR

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Basic constructor&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Lag-length selection&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; AIC&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; AICC&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; BIC&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; HQC&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; VAR(1) form&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Impulse response function (IRFs)&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Identification

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Reduce form&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Cholesky&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; BQ&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Uligh&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; HFI&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Confidence bands

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Asymptotic&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Bootstrap&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; Bootstrap-after-bootstrap&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Local projection IRFs

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Lag-length selection&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Confidence bands&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Standard&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Bootstrap&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;using VARs
V = VAR(Y, p, i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;Y&lt;/code&gt; is a matrix with data, &lt;code&gt;p&lt;/code&gt; is the lag-length and &lt;code&gt;i&lt;/code&gt; is a Boolean for including an intercept (default is true). It returns a fitted VAR(p) model with the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-julia&#34;&gt;type VAR
  Y::Array # dep. variables
  X::Array # covariates
  β::Array # parameters
  ϵ::Array # residuals
  Σ::Array # VCV matrix
  p::Int64 # lag-length
  i::Bool # true or false for including an intercept (default is true)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can access to each element writing &lt;code&gt;V.&lt;/code&gt; and than the element you are interested in (for example for the covariates &lt;code&gt;V.X&lt;/code&gt;).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
